:next_link: 01_values
:load_files: ["code/intro.js"]

= 소개 =

이것은 ((컴퓨터))가 당신이 원하는 것을 하게 하는 것에 관한 책이다.
오늘날 컴퓨터는 스크류드라이버와 같이 일반적이지만 
더 복잡한 것들이 숨어 있어 실행시키고 이해하기 어렵다. 
많은 이들에게 있어 약간은 다른 것들을 위협하며 외계인으로 남아있다.

image::img/generated/computer.png[alt="Communicating with a computer"]

(((그래픽 사용자 인터페이스))) 우리는 사회적이고 공간적인 추론에 재능을 가진 
철벅거리는 생물학적 유기체인 우리와 무의미한 데이터의 감정없는 조종자인 
컴퓨터 사이의 의사소통 차이 사이에 다리를 놓는 2개의 효과적인 방법을 발견했다.
하나는 물질적 세계내 우리의 감각에 호소하는 것으로 세계를 흉내내 
손가락을 이용하여 화면위에서 형태를 조작하도록 하는 인터페이스를 이룬다.
이는 평상시의 기계 인터페이스에 매우 잘 동작한다.

(((프로그래밍 언어)))그러나 인터페이스 디자이너가 예상치 않은 
컴퓨터와의 의사소통에 대하여 마우스 클릭을 이용한 접근을 사용하는 
좋은 방법은 아직 찾지 못했다. 임의의 작업을 실행토록 컴퓨터에게 명령하는 
것과 같이 제한없는 인터페이스에서 언어에 대한 재능을 사용하는 
접근에 있어 더 운이 좋았다: 기계에 언어를 가르치는 것 말이다.

(((인간 언어)))(((표현능력)))인간의 언어는 다른 여러 가지 것들을 말할 수 
있도록 여러 방법으로 결합된 단어와 구문을 허용한다. 컴퓨터 언어가 
일반적으론 문법에 있어 덜 유연하지만 비슷한 원칙을 따른다.

(((자바스크립트,의 효용)))(((격식없는 계산)))일반적인 컴퓨터 사용은 지난 
20년 동안 훨씬 널리 퍼졌고 컴퓨터와 소통하던 사람들에 의해 기본적으로 
쓰이던 언어 기반의 인터페이스는 그래픽 인터페이스로 광범위하게 교체되었다.
그러나 그들은 당신이 어디에서 볼 지 안다면 여전히 그 곳에 있다.
그런 언어 중 하나인 자바스크립트는 거의 모든 웹 ((브라우저)) 안에 
구성되어 있고 그래서 모든 사용자기기에서 사용 가능하다.

indexsee:[웹 브라우저,브라우저]이 책은 당신이 이 언어에 충분히 익숙해지도록 
하기 위한 것이다. 당신이 원하는 것을 컴퓨터가 하도록 가능케 하는 것 말이다.

== 개발에 대해 ==

[인용, 공자]
____
(((공자)))나는 배우기를 바라지 않는 자들을 깨우치려 하지 않으며 혹은 
그들 스스로에게 설명하려는 것을 열망하지 않는 자들을 자극하지 않는다. 
만약 내가 정사각형의 한 모서리를 가르키고 그들이 나에게 다른 세 지점을 
가르킬 수 없다면 나는 그 지점에 대해 다시 이르지 않을 것이다.
____

(((프로그래밍,의 어려움)))자바스크립트를 설명할 뿐만 아니라, 또한 
프로그래밍의 기본 원칙을 소개할 것이다. 프로그래밍, 이건 힘든 것이다.
기본 규칙들은 일반적으로 간단하고 명료하다. 하지만 이런 규칙들 위에서 
구성된 프로그램은 그들만의 규칙과 복잡도를 설명할 정도로 복잡해지는 
경향이 있다. 당신만의 미로를 만들 것인데, 어느 정도는 당신이 그 안에서 
길을 잃을 수도 있다.

(((배움)))이 책을 읽을 때 혼란스럽게 느껴질 때가 있을 것이다. 
프로그래밍이 처음이라면, 이해를 도울 여러 새로운 자료들이 있을 것이다.
이 자료의 대부분은 당신이 추가 연결을 하도록 요구하는 방법으로 _결합_될 것이다.

필요한 노력을 하는 것은 당신에게 달렸다. 이 책을 따라오도록 노력할 때, 
당신의 능력에 대하여 성급하게 어떤 결론에 도달하지 말라. 
당신은 괜찮다-그냥 지속하기만 하면 된다. 숨을 들이마시고 어떤 자료는 
다시 읽어라, 그리고 _언제나_ 예제 프로그램을 확실히 읽고 이해하고 ((연습하라)).
배우는 것은 힘든 작업이지만, 당신이 배우는 모든 것은 당신의 것이고 
그 이후의 배움을 더 쉽게 만들 것이다.

[인용, Joseph Weizenbaum, Computer Power and Human Reason]
____
(((Weizenbaum+++,+++ Joseph)))컴퓨터 프로그래머는 그 혹은 그녀 홀로만이 
맡고 있는 우주의 창조자이다. 가상의 무한 복잡도를 가진 우주는 
컴퓨터 프로그램의 형태로 창조가능하다.
____

(((프로그램,의 자연)))(((데이터)))어떤 프로그램은 많은 것들이다. 이는 
프로그래머에 의해 타이핑된 글자 조각이고 컴퓨터에게 그것이 하는 뭔가를 
하도록 물리력을 지시하는 것이며 컴퓨터의 메모리안 데이터이지만 
이 동일한 메모리 위에서 발생되는 활동을 통제한다. 프로그램을 우리에게 
익숙한 객체에 비유하려고 노력하는 유추는 충분하지 않다.
표면적으로 맞는 것중 하나는 기계의 그것이다. 나눠진 여러 부분들이 
서로 관련되고 전체를 움직이게 만드는 경향이 있다. 이런 부분들이 
서로 연결되고 전체의 동작에 기여하는 방법을 고려해야 한다.

(((computer)))컴퓨터는 이런 비물질 기계의 숙주로 행동하기 위해 
만들어진 기계이다. 컴퓨터 스스로가 할 수 있는 것은 바보같이 간단한 것들이다.
그것들이 굉장히 유용한 이유는 이러한 것들을 믿을 수 없을 만큼 빠른 
속도로 한다는 것이다. 굉장히 복잡한 것을 하기 위해 프로그램은 
엄청난 수의 이런 간단한 활동을 독창적으로 결합할 수 있다.

(((programming,joy of)))우리 중 몇몇에겐, 컴퓨터 프로그래밍을 
작성하는 것이 매력적인 게임이다. 프로그램은 생각을 건축하는 것이다.
이것은 건축에 비용이 많이 들지 않으며, 무게도 없고, 타이핑하는 
우리의 손 아래에서 쉽게 자라난다.

그러나 주의하지 않으면, 프로그램의 크기와 ((복잡도))는 그것을 만든 
이조차도 혼란스럽게 만들며 조절이 불가능할 정도로 자랄 것이. 
프로그램을 조절가능한 상태로 유지하는 것은 프로그래밍의 주요 
문제이다. 프로그램이 동작할 때 아름답다. 프로그래밍 예술은 복잡도를 
조절하는 기술이다. 굉장한 프로그램은 그것의 복잡도 안에서 
억제생성되어 간단한 것이다.

(((programming style)))(((best practices)))많은 프로그래머들은 이 복잡도가 
그들의 프로그램안에서 잘 이해된 기술의 작은 세트를 사용할 때에만 
가장 잘 관리된다고 생각한다. 그들은 프로그램이 가져야 하는 형태를 
묘사하는 엄격한 규칙("best practives")을 구성하였고 더 열정적으로 
그들 사이에서 이 안전한 작은 영역의 밖으로 나가 누가 _나쁜_ 
프로그래머가 될 지 고려할 것이다.

(((experiment)))(((learning)))프로그래밍의 풍요로움에 대한 어떤 적개심- 어떤 솔직하고 예상가능한 무엇에 대한 그것을 줄이기 위한 노력, 모든 이상하고 아름다운 프로그앰에 대한 터부를 대체하려는 노력!What hostility to the richness of
programming—to try to reduce it to something straightforward and
predictable, to place a taboo on all the weird and beautiful programs!
The landscape of programming techniques is enormous, fascinating in
its diversity, and still largely unexplored. It is certainly dangerous
going, luring the inexperienced programmer into all kinds of
confusion, but that only means you should proceed with caution and
keep your wits about you. As you learn there will always be new
challenges and new territory to explore. Programmers who refuse to
keep exploring will stagnate, forget their joy, and get bored with
their craft.

== Why language matters ==

(((programming language)))(((machine code)))(((binary data)))In the
beginning, at the birth of computing, there were no programming
languages. Programs looked something like this:

----
00110001 00000000 00000000
00110001 00000001 00000001
00110011 00000001 00000010
01010001 00001011 00000010
00100010 00000010 00001000
01000011 00000001 00000000
01000001 00000001 00000001
00010000 00000010 00000000
01100010 00000000 00000000
----

(((programming,history of)))(((punch card)))(((complexity)))That is a
program to add the numbers from 1 to 10 together and print out the
result: `1 + 2 + ... + 10 = 55`. It could run on a simple,
hypothetical machine. To program early computers, it was necessary to
set large arrays of switches in the right position or punch holes in
strips of cardboard and feed them to the computer. You can probably imagine
how tedious and error-prone this procedure was. Even writing simple
programs required much cleverness and discipline. Complex ones were
nearly inconceivable.

(((bit)))(((wizard (mighty))))Of course, manually entering these
arcane patterns of bits (the ones and zeros) did give the programmer
a profound sense of being a mighty wizard. And that has to be worth
something in terms of job satisfaction.

(((memory)))(((instruction)))Each line of the previous program contains a
single instruction. It could be written in English like this:

[source,text/plain]
----
1. Store the number 0 in memory location 0.
2. Store the number 1 in memory location 1.
3. Store the value of memory location 1 in memory location 2.
4. Subtract the number 11 from the value in memory location 2.
5. If the value in memory location 2 is the number 0,
   continue with instruction 9.
6. Add the value of memory location 1 to memory location 0.
7. Add the number 1 to the value of memory location 1.
8. Continue with instruction 3.
9. Output the value of memory location 0.
----

(((readability)))(((naming)))(((variable)))Although that is already
more readable than the soup of bits, it is still rather unpleasant. It
might help to use names instead of numbers for the instructions and
memory locations.

[source,text/plain]
----
 Set “total” to 0.
 Set “count” to 1.
[loop]
 Set “compare” to “count”.
 Subtract 11 from “compare”.
 If “compare” is zero, continue at [end].
 Add “count” to “total”.
 Add 1 to “count”.
 Continue at [loop].
[end]
 Output “total”.
----

(((loop)))(((jump)))(((summing example)))Can you see how the program
works at this point? The first two lines give
two memory locations their starting values: `total` will be used to
build up the result of the computation, and `count` will keep track of the
number that we are currently looking at. The lines using `compare` are
probably the weirdest ones. The program wants to see
whether `count` is equal to 11 in order to decide whether it can stop
running. Because our hypothetical machine is rather primitive, it can only
test whether a number is zero and make a decision (or jump) based on
that. So it uses the memory location labeled `compare` to compute the
value of `count - 11` and makes a decision based on that value. The
next two lines add the value of `count` to the result and increment
`count` by 1 every time the program has decided that `count` is not 11 yet.

Here is the same program in JavaScript:

[source,javascript]
----
var total = 0, count = 1;
while (count <= 10) {
  total += count;
  count += 1;
}
console.log(total);
// → 55
----

(((while loop)))(((loop)))This version gives us a few more improvements.
Most importantly, there is no need to specify the way we want the
program to jump back and forth anymore. The `while` language
construct takes care of that. It continues executing the block
(wrapped in braces) below it as long as the condition it was given
holds. That condition is `count <= 10`, which means “++count++ is less than or equal to
10”. We no longer have to create a temporary value and compare that
to zero, which was an uninteresting detail. Part of the power of
programming languages is that they take care of uninteresting details
for us.

(((console.log)))At the end of the program, after the `while` construct has
finished, the `console.log` operation is applied to the result in
order to write it as output.

(((sum function)))(((range
function)))(((abstraction)))(((function)))Finally, here is what the
program could look like if we happened to have the convenient
operations `range` and `sum` available, which respectively create a
((collection)) of numbers within a range and compute the sum of a
collection of numbers:

// start_code

[source,javascript]
----
console.log(sum(range(1, 10)));
// → 55
----

(((readability)))The moral of this story is that the same program can
be expressed in long and short, unreadable and readable ways. The
first version of the program was extremely obscure, whereas this last
one is almost English: `log` the `sum` of the `range` of numbers from
1 to 10. (We will see in link:04_data.html#data[later chapters] how to
build operations like `sum` and `range`.)

(((programming language,power of)))(((composability)))A good
programming language helps the programmer by allowing them to talk
about the actions that the computer has to perform on a higher level.
It helps omit uninteresting details, provides convenient building
blocks (such as `while` and `console.log`), allows you to define your
own building blocks (such as `sum` and `range`), and makes those blocks
easy to compose.

== What is JavaScript? ==

indexsee:[WWW,World Wide Web] indexsee:[Web,World Wide Web](((history)))(((Netscape)))(((browser)))(((web
application)))(((JavaScript)))(((JavaScript,history of)))(((World Wide
Web))) JavaScript was introduced in 1995 as a way to add programs to
web pages in the Netscape Navigator browser. The language has since
been adopted by all other major graphical web browsers. It has made modern
web applications possible—applications with which you can interact
directly, without doing a page reload for every action. But it is also used in more
traditional websites to provide various forms of interactivity and
cleverness.

(((Java)))(((naming)))It is important to note that JavaScript has
almost nothing to do with the programming language named Java. The
similar name was inspired by marketing considerations, rather than
good judgment. When JavaScript was being introduced, the Java language
was being heavily marketed and was gaining popularity. Someone
thought it was a good idea to try to ride along on this success. Now we
are stuck with the name.

(((ECMAScript)))(((compatibility)))After its adoption outside of
Netscape, a ((standard)) document was written to describe the way the
JavaScript language should work to make sure the various pieces of
software that claimed to support JavaScript were actually talking
about the same language. This is called the ECMAScript standard, after
the Ecma International organization that did the standardization. In
practice, the terms ECMAScript and JavaScript can be used interchangeably—they
are two names for the same language.

(((JavaScript,weaknesses of)))(((debugging)))There are those who will
say _terrible_ things about the JavaScript language. Many of these
things are true. When I was required to write something in JavaScript
for the first time, I quickly came to despise it. It would accept
almost anything I typed but interpret it in a way that was completely
different from what I meant. This had a lot to do with the fact that I
did not have a clue what I was doing, of course, but there is a real
issue here: JavaScript is ridiculously liberal in what it allows. The
idea behind this design was that it would make programming in
JavaScript easier for beginners. In actuality, it mostly makes finding
problems in your programs harder because the system will not point
them out to you.

(((JavaScript,flexibility of)))(((flexibility)))This flexibility also
has its advantages, though. It leaves space for a lot of techniques
that are impossible in more rigid languages, and as you will see (for
example in link:10_modules.html#modules[Chapter 10]) it
can be used to overcome some of JavaScript's shortcomings. After
((learning)) the language properly and working with it for a while, I have
learned to actually _like_ JavaScript.

(((future)))(((JavaScript,versions of)))(((ECMAScript)))(((ECMAScript
6)))There have been several versions of JavaScript. ECMAScript
version 3 was the widely supported version in the time of
JavaScript's ascent to dominance, roughly between 2000 and 2010.
During this time, work was underway on an ambitious version 4, which
planned a number of radical improvements and extensions to the
language. Changing a living, widely used language in such a radical
way turned out to be politically difficult, and work on the version 4
was abandoned in 2008, leading to the much less ambitious version 5
coming out in 2009. We're now at the point where all major
browsers support version 5, which is the language version that
this book will be focusing on. A version 6 is in the process of
being finalized, and some browsers are starting to support new
features from this version.

(((JavaScript,uses of)))Web browsers are not the only platforms on
which JavaScript is used. Some databases, such as MongoDB and CouchDB,
use JavaScript as their scripting and query language. Several
platforms for desktop and server programming, most notably the
((Node.js)) project (the subject of link:20_node.html#node[Chapter
20]) are providing a powerful environment for programming JavaScript
outside of the browser.

== Code, and what to do with it ==

(((reading code)))(((writing code)))Code is the text that makes up
programs. Most chapters in this book contain quite a lot of it. In my
experience, reading code and writing ((code)) are indispensable parts of
((learning)) to program, so try to not just glance over the examples. Read
them attentively and understand them. This may be slow and confusing
at first, but I promise that you will quickly get the hang of it. The
same goes for the ((exercises)). Don't assume you understand them
until you've actually written a working solution.

(((interpretation)))I recommend you try your solutions to exercises
in an actual JavaScript interpreter. That way, you'll get immediate feedback on
whether what you are doing is working, and, I hope, you'll be
tempted to ((experiment)) and go beyond the exercises.

ifdef::interactive_target[]

When reading this book in your browser, you can edit (and run) all
example programs by clicking them.

endif::interactive_target[]

ifdef::book_target[]

(((download)))(((sandbox)))(((running code)))The easiest way to run
the example code in the book, and to experiment with it, is to look it
up in the online version of the book at
http://eloquentjavascript.net/[_eloquentjavascript.net_]. There, you
can click any code example to edit and run it and to see the
output it produces. To work on the exercises, go to
http://eloquentjavascript.net/code[_eloquentjavascript.net/code_],
which provides starting code for each coding exercise and allows you
to look at the solutions.

endif::book_target[]

(((developer tools)))(((JavaScript console)))If you want to run the
programs defined in this book outside of the book's sandbox, some care
is required. Many examples stand on their own and should work in any
JavaScript environment. But code in later chapters is mostly written
for a specific environment (the browser or Node.js) and can run only
there. In addition, many chapters define bigger programs, and the
pieces of code that appear in them depend on each other or on external
files. The http://eloquentjavascript.net/code[sandbox] on the website
provides links to Zip files containing all of the scripts and data
files necessary to run the code for a given chapter.

== Overview of this book ==

This book contains roughly three parts. The first 11 chapters discuss
the JavaScript language itself. The next eight chapters are about web
((browsers)) and the way JavaScript is used to program them. Finally,
two chapters are devoted to ((Node.js)), another environment to program
JavaScript in.

Throughout the book, there are five _project chapters_, which describe
larger example programs to give you a taste of real programming. In
order of appearance, we will work through building an
link:07_elife.html#elife[artificial life simulation], a
link:11_language.html#language[programming language], a
link:15_game.html#game[platform game], a
link:19_paint.html#paint[paint program], and a
link:21_skillsharing.html#skillsharing[dynamic website].

The language part of the book starts with four chapters to introduce
the basic structure of the JavaScript language. They introduce
link:02_program_structure.html#program_structure[control structures]
(such as the `while` word you saw in this introduction),
link:03_functions.html#functions[functions] (writing your own
operations), and link:04_data.html#data[data structures]. After these,
you will be able to write simple programs. Next, Chapters
link:05_higher_order.html#higher_order[5] and
link:06_object.html#object[6] introduce techniques to use functions
and objects to write more _abstract_ code and thus keep complexity
under control.

After a link:07_elife.html#elife[first project chapter], the first
part of the book continues with chapters on
link:08_error.html#error[error handling and fixing], on
link:09_regexp.html#regexp[regular expressions] (an important tool for
working with text data), and on
link:10_modules.html#modules[modularity]—another weapon against
complexity. The link:11_language.html#language[second project chapter]
concludes the first part of the book.

The second part, Chapters link:12_browser.html#browser[12] to
link:19_paint.html#paint[19], describes the tools that browser
JavaScript has access to. You'll learn to display things on the screen
(Chapters link:13_dom.html#dom[13] and
link:16_canvas.html#canvas[16]), respond to user input (Chapters
link:14_event.html#event[14] and link:18_forms.html#forms[18]), and
communicate over the network (link:17_http.html#http[Chapter 17]).
There are again two project chapters in this part.

After that, link:20_node.html#node[Chapter 20] describes Node.js, and
link:21_skillsharing.html#skillsharing[Chapter 21] builds a simple web
system using that tool.

ifdef::commercial_target[]

Finally, link:22_fast.html#fast[Chapter 22] describes some of the
considerations that come up when optimizing JavaScript programs for
speed.

endif::commercial_target[]

== Typographic conventions ==

(((factorial function)))In this book, text written in a `monospaced`
font will represent elements of programs—sometimes
they are self-sufficient fragments, and sometimes they just refer to
part of a nearby program. Programs (of which you have already seen a
few), are written as follows:

[source,javascript]
----
function fac(n) {
  if (n == 0)
    return 1;
  else
    return fac(n - 1) * n;
}
----

(((console.log)))Sometimes, in order to show the output that a program
produces, the expected output is written after it, with two slashes
and an arrow in front.

[source,javascript]
----
console.log(fac(8));
// → 40320
----

Good luck!
